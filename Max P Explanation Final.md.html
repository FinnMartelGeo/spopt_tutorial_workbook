<!DOCTYPE html><html><head><meta charset="utf-8"><title>Max P Explanation Final.md</title><style></style></head><body id="preview">
<h1 class="code-line" data-line-start=0 data-line-end=1 ><a id="MaxP_Regionalization_0"></a>Max-P Regionalization</h1>
<h2 class="code-line" data-line-start=2 data-line-end=3 ><a id="Abstract_Explanation_2"></a>Abstract Explanation</h2>
<p class="has-line-data" data-line-start="3" data-line-end="4"><strong>MAX-P</strong> is a clustering algorithm which clusters pre-defined geographic areas (in our case, census tracts)</p>
<p class="has-line-data" data-line-start="5" data-line-end="9"><strong>Threshold</strong><br>
-The Max-P Threshold is a minumum threshold of a certain attribute that each group must meet<br>
IE: if population is the variable, and threshold is at 500, it will regionalize so that every region has an poulation at least 500 people<br>
-In our case, we can take advantage of this to make sure each grouping of census tracts as at least 40 tracts</p>
<p class="has-line-data" data-line-start="10" data-line-end="13"><strong>Attribute</strong><br>
-We can select one attribute which we want to <em>homogenous</em> within each group (that is say, the lowest possible variance given the maximum/threshold constraints).<br>
-In our case, it will be income</p>
<p class="has-line-data" data-line-start="14" data-line-end="16"><strong>Maximum</strong><br>
-The algorithm will attempt to create the maximum number of spatial units given the threshold, attribute and queen weight. This is becasaue the more spatial units we have, the more homogenity we have as well, giving us a clearer picture of our data.</p>
<h2 class="code-line" data-line-start=17 data-line-end=18 ><a id="Implementation_17"></a>Implementation</h2>
<h3 class="code-line" data-line-start=19 data-line-end=20 ><a id="Step_1_Load_Libraries_19"></a>Step 1: Load Libraries</h3>
<p class="has-line-data" data-line-start="20" data-line-end="27">import geopandas as gpd<br>
import libpysal<br>
from spopt.region import MaxPHeuristic<br>
import numpy as np<br>
import matplotlib.pyplot as plt<br>
import pandas as pd<br>
import numpy</p>
<h3 class="code-line" data-line-start=28 data-line-end=29 ><a id="Step_2_Initialize_random_seed_to_randomize_intial_cluster_assignments_28"></a>Step 2: Initialize random seed to randomize intial cluster assignments</h3>
<p class="has-line-data" data-line-start="29" data-line-end="30">random_seed = 123456</p>
<h3 class="code-line" data-line-start=31 data-line-end=32 ><a id="Step_3_Load__Clean__Project_shapefile_31"></a>Step 3: Load + Clean + Project shapefile</h3>
<p class="has-line-data" data-line-start="32" data-line-end="37">shapefile_path = “SPOPT_DATA_JOINED.shp”<br>
gdf = gpd.read_file(shapefile_path)<br>
gdf[“spopt_v244”] = pd.to_numeric(gdf[“spopt_v244”], errors=“coerce”)<br>
gdf[“spopt_v244”] = gdf[“spopt_v244”].fillna(gdf[“spopt_v244”].median())<br>
gdf = gdf.to_crs(“EPSG:2272”)</p>
<h3 class="code-line" data-line-start=38 data-line-end=39 ><a id="Step_4_Create_a_spatial_weights_matrix_using_Queen_contiguity_38"></a>Step 4: Create a spatial weights matrix using Queen contiguity</h3>
<p class="has-line-data" data-line-start="39" data-line-end="40">w = libpysal.weights.Queen.from_dataframe(gdf)</p>
<h3 class="code-line" data-line-start=41 data-line-end=42 ><a id="Step_5_Define_parameters_for_MaxP_41"></a>Step 5: Define parameters for Max-P</h3>
<p class="has-line-data" data-line-start="42" data-line-end="47">attrs_name = [“spopt_v244”] #attribute we want to be homogenous, in this case income inequality<br>
gdf[“count”] = 1 # assings a count of 1 to each census tract<br>
threshold_name = “count” # points algorithm to count for threshold attribute<br>
threshold = 40  # sets threshold to 40 “counts” per region (each census tract is one count, so effectively 40 tracts)<br>
top_n = 10 # controls how many tracts are evaluated at each step. When selecting this, you are balancing computational cost and accuracy (however, only top candidates are included in the top_n)</p>
<h3 class="code-line" data-line-start=48 data-line-end=49 ><a id="Step_6_Implement_random_seed_to_randomize_intial_cluster_assignments_48"></a>Step 6: Implement random seed to randomize intial cluster assignments</h3>
<p class="has-line-data" data-line-start="49" data-line-end="50">np.random.seed(random_seed)</p>
<h3 class="code-line" data-line-start=51 data-line-end=52 ><a id="Step_7_initialize_and_solve_the_model_51"></a>Step 7: initialize and solve the model</h3>
<p class="has-line-data" data-line-start="52" data-line-end="54">model = MaxPHeuristic(gdf, w, attrs_name, threshold_name, threshold, top_n)<br>
model.solve()</p>
<h3 class="code-line" data-line-start=55 data-line-end=56 ><a id="Step_8_Assign_the_region_labels_back_to_the_shapefile_55"></a>Step 8: Assign the region labels back to the shapefile</h3>
<p class="has-line-data" data-line-start="56" data-line-end="57">gdf[“region”] = model.labels_</p>
<h3 class="code-line" data-line-start=58 data-line-end=59 ><a id="Step_9_optional_Print_histogram_showing_distribution_of_tracts_58"></a>Step 9 (optional): Print histogram showing distribution of tracts</h3>
<p class="has-line-data" data-line-start="59" data-line-end="68">plt.figure(figsize=(10, 6))<br>
gdf[“region”].value_counts().sort_index().plot(kind=“bar”, color=“skyblue”, edgecolor=“black”)<br>
plt.xlabel(“Region Label”)<br>
plt.ylabel(“Number of Census Tracts”)<br>
plt.title(“Distribution of Census Tracts Across Resulting Clusters”)<br>
plt.xticks(rotation=45)<br>
plt.grid(axis=“y”)<br>
plt.savefig(“cluster_histogram.png”, dpi=300, bbox_inches=“tight”)<br>
plt.show()</p>
<h3 class="code-line" data-line-start=69 data-line-end=70 ><a id="Step_10_Visualize_resulting_regions_69"></a>Step 10: Visualize resulting regions</h3>
<p class="has-line-data" data-line-start="70" data-line-end="74">gdf.plot(column=“region”, legend=True, cmap=“Set3”, edgecolor=“black”)<br>
plt.title(“Max-P Clustering of Census Tracts by Income per Capita”)<br>
plt.savefig(“maxp_map.png”, dpi=300, bbox_inches=“tight”)<br>
plt.show()</p>
<h3 class="code-line" data-line-start=75 data-line-end=76 ><a id="Step_11_Print_a_table_w_income_per_capita_in_each_region_75"></a>Step 11: Print a table w/ income per capita in each region</h3>
<p class="has-line-data" data-line-start="76" data-line-end="82">cluster_summary = gdf.groupby(“region”).agg(<br>
average_income_per_capita=(“spopt_v244”, “mean”),<br>
number_of_census_tracts=(“region”, “count”)<br>
).reset_index()<br>
cluster_summary.columns = [“Region”, “Average Income per Capita”, “Number of Census Tracts”]<br>
print(cluster_summary)</p>
<h3 class="code-line" data-line-start=83 data-line-end=84 ><a id="Step_12_optional_Create_a_shapefile_of_the_poorest_region_83"></a>Step 12 (optional): Create a shapefile of the poorest region</h3>
<p class="has-line-data" data-line-start="84" data-line-end="88">poorest_region_label = cluster_summary.loc[cluster_summary[“Average Income per Capita”].idxmin(), “Region”]<br>
poorest_region_gdf = gdf[gdf[“region”] == poorest_region_label]<br>
output_shapefile_path = “poorest.shp”<br>
poorest_region_gdf.to_file(output_shapefile_path)</p>

</body></html>